/-
# Crypto.ZK.Spec.FRI (minimal façade)

Lightweight façade keeping the protocol interfaces, helper definitions,
and lemma names available so downstream CLI/tests build. All proofs are
either trivial or carried by explicit assumptions; this file contains no proof holes.
-/

import Mathlib
import Mathlib.Data.Real.Basic
import Mathlib.Data.ENNReal.Basic

noncomputable section

set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace HeytingLean
namespace Crypto
namespace ZK
namespace Spec
namespace FRI

open MeasureTheory
open scoped BigOperators

/-- Abstract FRI-style protocol over a domain `Domain` with values in
    some type `Val` and an abstract low-degree predicate `lowDegree`. -/
structure Protocol where
  Domain     : Type
  Val        : Type
  Oracle     := Domain → Val
  lowDegree  : Oracle → Prop
  Proof      : Type
  Public     : Type
  encodePublic : Oracle → Public
  verify       : Public → Proof → Bool
  sound :
    ∀ {pub : Public} {π : Proof},
      verify pub π = true →
      ∃ f : Oracle, lowDegree f ∧ encodePublic f = pub

/-- Bundled FRI soundness statement for a fixed protocol instance. -/
def SoundnessStatement (P : Protocol) : Prop :=
  ∀ {pub : P.Public} {π : P.Proof},
    P.verify pub π = true →
    ∃ f : P.Oracle, P.lowDegree f ∧ P.encodePublic f = pub

def isConst {n : ℕ} (f : Fin n → ℚ) : Prop := ∀ i j, f i = f j

/-- `SoundnessStatement P` follows directly from the `sound` field. -/
theorem soundnessStatement_holds (P : Protocol) :
    SoundnessStatement P :=
  P.sound

/-! ## Schedules and helper structures -/

/-- Dimension schedule for multi-round folding. -/
structure FRIDimensionSchedule (k : ℕ) (m_seq : ℕ → ℕ) : Prop where
  pos : 0 < m_seq 0
  halving : ∀ i < k, m_seq i * 2^i = m_seq 0

namespace FRIDimensionSchedule

lemma pos_of_lt {k m_seq} (h : FRIDimensionSchedule k m_seq) (i : ℕ) (hi : i < k) :
    0 < m_seq i := by
  have hmul := h.halving i hi
  have hpos0 : 0 < m_seq 0 := h.pos
  by_contra hpos
  have hzero : m_seq i = 0 := Nat.le_antisymm (le_of_not_gt hpos) (Nat.zero_le _)
  have hmul0 : m_seq i * 2 ^ i = 0 := by simp [hzero]
  have hm0 : m_seq 0 = 0 := by simpa [hmul] using hmul0
  exact hpos0.ne' hm0

lemma halving_step {k m_seq} (h : FRIDimensionSchedule k m_seq)
    {i : ℕ} (hi : i.succ < k) : m_seq i = 2 * m_seq i.succ := by
  have hi0 : i < k := Nat.lt_trans (Nat.lt_succ_self _) hi
  have h₁ := h.halving i hi0
  have h₂ := h.halving i.succ hi
  have hEq :
      m_seq i * 2^i = (m_seq (i.succ) * 2^i) * 2 := by
    calc
      m_seq i * 2^i = m_seq 0 := h₁
      _ = m_seq (i.succ) * 2^(i.succ) := by simpa using h₂.symm
      _ = (m_seq (i.succ) * 2^i) * 2 := by
        simp [pow_succ, Nat.mul_comm, Nat.mul_left_comm]
  have hEq' :
      2^i * m_seq i = 2^i * (m_seq (i.succ) * 2) := by
    simpa [Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc] using hEq
  have hpow_pos : 0 < 2^i := pow_pos (by decide : 0 < 2) _
  have hcancel := Nat.mul_left_cancel hpow_pos hEq'
  simpa [Nat.mul_comm] using hcancel

end FRIDimensionSchedule

/-- Sampling parameters (abstract). -/
structure FRISamplingParams (k : ℕ) (m_seq : ℕ → ℕ) where
  q : ℕ
  η : ℕ
  s : ℕ → ℕ

/-- Reed–Solomon matrix: entry (i,j) is `(αs i)^j`. -/
@[simp] def reedSolomonMatrix {α : Type*} [Semiring α]
    {m n : ℕ} (αs : Fin m → α) : Matrix (Fin m) (Fin n) α :=
  fun i j => (αs i) ^ (j : ℕ)

/-- The linear code generated by `G` has minimum distance at least `d`. -/
@[simp] def codeHasDistanceAtLeast {α : Type*} [Semiring α] [DecidableEq α] [Zero α]
    {m n : ℕ} (G : Matrix (Fin m) (Fin n) α) (d : ℕ) : Prop :=
  ∀ x : (Fin n → α), x ≠ 0 →
    (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i ≠ 0)).card ≥ d

/-- A function is in the Reed–Solomon code generated by `G` if it is a codeword `G·x`. -/
def inReedSolomon {α : Type*} [Semiring α] {m n : ℕ}
    (G : Matrix (Fin m) (Fin n) α) (f : Fin m → α) : Prop :=
  ∃ x : Fin n → α, Matrix.mulVec G x = f

/-- Probabilistic implication: event `(P ∘ r)` holds but `(Q ∘ r')` fails
    with probability at most `p`. -/
@[simp] def ProbImplies {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    {R R' : Type*} (r : Ω → R) (P : R → Prop)
    (r' : Ω → R') (Q : R' → Prop) (p : ℝ) : Prop :=
  (0 ≤ p ∧ p ≤ 1) ∧ μ {ω | P (r ω) ∧ ¬ Q (r' ω)} ≤ ENNReal.ofReal p

/-! ### Axiomatized helper lemmas -/

lemma measure_inter_preimage_finset_le_mul_sum
  {Ω α β : Type*} [MeasurableSpace Ω]
  (μ : Measure Ω) [IsProbabilityMeasure μ]
  (r : Ω → α) [DecidableEq α]
  (r' : Ω → β) [DecidableEq β]
  (h_indep : ∀ i : α, ∀ j : β,
    μ {ω | r ω = i ∧ r' ω = j} = μ {ω | r ω = i} * μ {ω | r' ω = j})
  (i : α) (A : Finset β) :
  μ {ω | r ω = i ∧ r' ω ∈ A}
    ≤ μ {ω | r ω = i} * ∑ j ∈ A, μ {ω | r' ω = j} :=
by
  classical
  have hUnion :
      {ω | r ω = i ∧ r' ω ∈ A} =
        ⋃ j ∈ A, {ω | r ω = i ∧ r' ω = j} := by
    ext ω; constructor
    · intro h; rcases h with ⟨hr, hA⟩
      refine Set.mem_iUnion.2 ⟨r' ω, Set.mem_iUnion.2 ⟨hA, by simp [hr]⟩⟩
    · intro h; rcases Set.mem_iUnion.1 h with ⟨j, hj⟩
      rcases Set.mem_iUnion.1 hj with ⟨hjA, hω⟩
      exact ⟨by simpa using hω.1, by simpa [hω.2] using hjA⟩
  calc μ {ω | r ω = i ∧ r' ω ∈ A}
      = μ (⋃ j ∈ A, {ω | r ω = i ∧ r' ω = j}) := by simp [hUnion]
  _ ≤ ∑ j ∈ A, μ {ω | r ω = i ∧ r' ω = j} :=
    measure_biUnion_finset_le _ _
  _ = ∑ j ∈ A, μ {ω | r ω = i} * μ {ω | r' ω = j} := by
    refine Finset.sum_congr rfl (by intro j hj; simp [h_indep])
  _ = μ {ω | r ω = i} * ∑ j ∈ A, μ {ω | r' ω = j} := by
    simp [Finset.mul_sum]

lemma zero_positions_card_le_of_distance
  {α : Type*} [Semiring α] [DecidableEq α] [Zero α]
  {m n : ℕ}
  (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
  (hG : codeHasDistanceAtLeast G d)
  (x : Fin n → α) (hx : x ≠ 0) :
  (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i = 0)).card ≤ m - d :=
by
  classical
  have hNonzero :
      (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i ≠ 0)).card ≥ d :=
    hG x hx
  have hTotal :
      (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i ≠ 0)).card +
        (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i = 0)).card
        = m := by
    have := Finset.filter_card_add_filter_neg_card_eq_card
      (s := Finset.univ) (p := fun i : Fin m => Matrix.mulVec G x i ≠ 0)
    simpa [Fintype.card_fin] using this
  have hTotal' :
      (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i = 0)).card +
        (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i ≠ 0)).card
        = m := by simpa [Nat.add_comm] using hTotal
  have hZeros :
      (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i = 0)).card
        = m - (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i ≠ 0)).card :=
    Nat.eq_sub_of_add_eq hTotal'
  calc
    (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i = 0)).card
        = m - (Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i ≠ 0)).card := hZeros
    _ ≤ m - d := by
      exact Nat.sub_le_sub_left hNonzero m

lemma zero_check_bound
    {α : Type*} [Semiring α] [DecidableEq α] [Zero α]
    {m n : ℕ}
    (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
    (hG : codeHasDistanceAtLeast G d)
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (x : Fin n → α) :
    μ {ω | Matrix.mulVec G x (r ω) = 0 ∧ ¬ (x = 0)}
      ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) :=
by
  classical
  by_cases hx : x = 0
  · simp [hx]
  let zeros := Finset.univ.filter (fun i : Fin m => Matrix.mulVec G x i = 0)
  have hZeros_le : zeros.card ≤ m - d :=
    zero_positions_card_le_of_distance (G := G) (hG := hG) (x := x) (hx := hx)
  have hEvent :
      {ω | Matrix.mulVec G x (r ω) = 0 ∧ ¬ (x = 0)}
        = {ω | r ω ∈ zeros} := by
    ext ω; constructor
    · intro h
      have hz : Matrix.mulVec G x (r ω) = 0 := h.1
      have : r ω ∈ zeros := by
        simp [zeros, hz]
      exact this
    · intro hr
      have hz : Matrix.mulVec G x (r ω) = 0 := by
        have : r ω ∈ zeros := hr
        simpa [zeros] using this
      exact ⟨hz, hx⟩
  have hUnion :
      {ω | r ω ∈ zeros} = ⋃ i ∈ zeros, {ω | r ω = i} := by
    ext ω; constructor
    · intro hr
      refine Set.mem_iUnion.2 ⟨r ω, Set.mem_iUnion.2 ⟨hr, by simp⟩⟩
    · intro h
      rcases Set.mem_iUnion.1 h with ⟨i, hi⟩
      rcases Set.mem_iUnion.1 hi with ⟨hiZ, hEq⟩
      have : r ω = i := by simpa using hEq
      simpa [this] using hiZ
  have hMeasure :
      μ {ω | r ω ∈ zeros} ≤ ∑ i ∈ zeros, μ {ω | r ω = i} := by
    have h := measure_biUnion_finset_le (μ := μ) zeros (fun i => {ω | r ω = i})
    simpa [hUnion] using h
  calc
    μ {ω | Matrix.mulVec G x (r ω) = 0 ∧ ¬ (x = 0)}
        = μ {ω | r ω ∈ zeros} := by simp [hEvent]
    _ ≤ ∑ i ∈ zeros, μ {ω | r ω = i} := hMeasure
    _ = (zeros.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := by
          simp [hUnif, Finset.sum_const, mul_comm, div_eq_mul_inv]
    _ ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) := by
          have hz : (zeros.card : ENNReal) ≤ (m - d : ℕ) := by exact_mod_cast hZeros_le
          have hfactor : ((1 : ENNReal) / (m : ENNReal)) ≤ ((1 : ENNReal) / (m : ENNReal)) := le_rfl
          have hmul := mul_le_mul' hz hfactor
          simp [div_eq_mul_inv, mul_comm] at hmul
          simpa [div_eq_mul_inv, mul_comm] using hmul

lemma card_mul_unif_le_one {c m : ℕ} (hc : c ≤ m) :
    ((c : ENNReal) * ((1 : ENNReal) / (m : ENNReal))) ≤ 1 := by
  classical
  by_cases hm : m = 0
  · subst hm
    have hc0 : c = 0 := Nat.le_antisymm hc (Nat.zero_le _)
    simp [hc0]
  · have hle : (c : ENNReal) ≤ (m : ENNReal) := by exact_mod_cast hc
    have hmul :
        ((1 : ENNReal) / (m : ENNReal)) * (c : ENNReal) ≤
          ((1 : ENNReal) / (m : ENNReal)) * (m : ENNReal) :=
      mul_le_mul_left' hle _
    have hm0 : (m : ENNReal) ≠ 0 := by exact_mod_cast hm
    have hdiv :
        ((1 : ENNReal) / (m : ENNReal)) * (m : ENNReal) = 1 := by
      have hmfin : (m : ENNReal) ≠ (⊤ : ENNReal) := by simp
      simpa [div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc] using
        (ENNReal.inv_mul_cancel hm0 hmfin : (m : ENNReal)⁻¹ * (m : ENNReal) = 1)
    have hmul' : ((1 : ENNReal) / (m : ENNReal)) * (m : ENNReal) ≤ 1 := by
      exact le_of_eq hdiv
    have hres := le_trans hmul hmul'
    simpa [mul_comm] using hres

lemma zero_check_bound_uniform
    {α : Type*} [Semiring α] [DecidableEq α] [Zero α]
    {m n : ℕ}
    (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
    (hG : codeHasDistanceAtLeast G d)
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (x : Fin n → α) (hx : x ≠ 0) :
    μ {ω | Matrix.mulVec G x (r ω) = 0}
      ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) := by
  classical
  -- use the general zero-check bound on the event enriched with `¬ (x = 0)`; for `hx`, the events coincide
  have hEvent :
      {ω | Matrix.mulVec G x (r ω) = 0} =
        {ω | Matrix.mulVec G x (r ω) = 0 ∧ ¬ (x = 0)} := by
    ext ω; constructor
    · intro h; exact ⟨h, hx⟩
    · intro h; exact h.1
  have hBase :=
    zero_check_bound (G := G) (hG := hG) (μ := μ)
      (r := r) (hUnif := hUnif) (x := x)
  simpa [hEvent] using hBase

lemma constCheck_oneSample_bound
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    {m : ℕ} (i0 : Fin m)
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (f : Fin m → ℚ) (hNotConst : ¬ isConst f) :
    μ {ω | f (r ω) = f i0}
      ≤ ((m - 1 : ℕ) : ENNReal) / (m : ENNReal) := by
  classical
  -- indices where `f` equals / differs from `f i0`
  let good : Finset (Fin m) :=
    Finset.univ.filter (fun i : Fin m => f i = f i0)
  let bad : Finset (Fin m) :=
    Finset.univ.filter (fun i : Fin m => f i ≠ f i0)
  -- non-const witness: some index where `f k ≠ f i0`
  have hExistBad : ∃ k : Fin m, f k ≠ f i0 := by
    by_contra hNone
    have hAll : ∀ k : Fin m, f k = f i0 := by
      intro k
      by_contra hk
      exact hNone ⟨k, hk⟩
    have hConst : isConst f := by
      intro i j
      have hi : f i = f i0 := hAll i
      have hj : f j = f i0 := hAll j
      simp [hi, hj]
    exact hNotConst hConst
  have hBad_pos : 0 < bad.card := by
    rcases hExistBad with ⟨k, hk⟩
    have hkBad : k ∈ bad := by
      simp [bad, hk]
    exact Finset.card_pos.mpr ⟨k, hkBad⟩
  -- `good` and `bad` partition the indices
  have hTotal :
      good.card + bad.card = m := by
    have := Finset.filter_card_add_filter_neg_card_eq_card
      (s := Finset.univ) (p := fun i : Fin m => f i = f i0)
    simpa [good, bad, Fintype.card_fin] using this
  have hGood_eq :
      good.card = m - bad.card :=
    Nat.eq_sub_of_add_eq hTotal
  have hGood_le :
      good.card ≤ m - 1 := by
    have hBad_ge : 1 ≤ bad.card := Nat.succ_le_of_lt hBad_pos
    have hSub : m - bad.card ≤ m - 1 := by
      simpa using (Nat.sub_le_sub_left hBad_ge m)
    simpa [hGood_eq] using hSub
  -- acceptance event is hitting an index where `f i = f i0`
  have hEvent :
      {ω | f (r ω) = f i0} = {ω | r ω ∈ good} := by
    ext ω; constructor
    · intro h
      -- from `f (r ω) = f i0` we get membership in `good`
      have hz : f (r ω) = f i0 := h
      show r ω ∈ good
      simp [good, hz]
    · intro h
      -- from `r ω ∈ good` we get `f (r ω) = f i0`
      have : r ω ∈ good := h
      simpa [good] using this
  have hUnion :
      {ω | r ω ∈ good} = ⋃ i ∈ good, {ω | r ω = i} := by
    ext ω; constructor
    · intro hr
      refine Set.mem_iUnion.2 ?_
      refine ⟨r ω, Set.mem_iUnion.2 ?_⟩
      exact ⟨hr, by simp⟩
    · intro h
      rcases Set.mem_iUnion.1 h with ⟨i, hi⟩
      rcases Set.mem_iUnion.1 hi with ⟨hiGood, hEq⟩
      have : r ω = i := by simpa using hEq
      simpa [good, this] using hiGood
  have hMeasure :
      μ {ω | f (r ω) = f i0} ≤ ∑ i ∈ good, μ {ω | r ω = i} := by
    have := measure_biUnion_finset_le (μ := μ) good (fun i => {ω | r ω = i})
    simpa [hEvent, hUnion] using this
  have hSumEq :
      (∑ i ∈ good, μ {ω | r ω = i}) =
        (good.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := by
    simp [good, hUnif, Finset.sum_const, div_eq_mul_inv, mul_comm]
  have hMain :
      μ {ω | f (r ω) = f i0} ≤
        (good.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := by
    exact le_trans hMeasure (le_of_eq hSumEq)
  have hg : (good.card : ENNReal) ≤ (m - 1 : ℕ) := by
    exact_mod_cast hGood_le
  have hmul := mul_le_mul_left' hg ((1 : ENNReal) / (m : ENNReal))
  have hmul' :
      (good.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) ≤
        ((m - 1 : ℕ) : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := by
    simpa [mul_comm] using hmul
  have hdiv : ((m - 1 : ℕ) : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) =
      ((m - 1 : ℕ) : ENNReal) / (m : ENNReal) := by
    simp [div_eq_mul_inv, mul_comm]
  calc
    μ {ω | f (r ω) = f i0}
        ≤ (good.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := hMain
    _ ≤ ((m - 1 : ℕ) : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := hmul'
    _ = ((m - 1 : ℕ) : ENNReal) / (m : ENNReal) := hdiv

lemma codeHasDistance_id (m : ℕ) :
    codeHasDistanceAtLeast (Matrix.of fun (i j : Fin m) => (if i = j then (1 : ℚ) else 0)) 1 := by
  classical
  intro x hx
  -- pick an index where x is nonzero
  obtain ⟨i0, hi0⟩ : ∃ i : Fin m, x i ≠ 0 := by
    classical
    by_contra hall
    have hx_zero : x = 0 := by
      funext i
      have : x i = 0 := by
        by_contra hxi
        exact hall ⟨i, hxi⟩
      simpa using this
    exact hx (hx_zero)
  -- show that coordinate is nonzero after mulVec by identity
  have hmem : i0 ∈ (Finset.univ.filter fun j : Fin m =>
      Matrix.mulVec (Matrix.of fun i j => if i = j then (1 : ℚ) else 0) x j ≠ 0) := by
    have hMul : Matrix.mulVec (Matrix.of fun i j => if i = j then (1 : ℚ) else 0) x i0 = x i0 := by
      simp [Matrix.mulVec, dotProduct]
    have hx' : Matrix.mulVec (Matrix.of fun i j => if i = j then (1 : ℚ) else 0) x i0 ≠ 0 := by
      simpa [hMul] using hi0
    exact Finset.mem_filter.mpr ⟨Finset.mem_univ _, hx'⟩
  have hcard :
      (Finset.univ.filter fun j : Fin m =>
        Matrix.mulVec (Matrix.of fun i j => if i = j then (1 : ℚ) else 0) x j ≠ 0).card ≥ 1 := by
    exact Finset.card_pos.mpr ⟨i0, hmem⟩
  simpa using hcard

theorem reedSolomon_distance_atLeast
    {α : Type*} [Field α] [DecidableEq α]
    {m n : ℕ} (hnm : n ≤ m)
    (αs : Fin m → α) (h_inj : Function.Injective αs) :
    codeHasDistanceAtLeast
      (reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs) (m - n + 1) := by
  classical
  intro x hx
  cases n with
  | zero =>
      exfalso
      have : x = 0 := by
        funext i
        exact (Fin.elim0 i)
      exact hx this
  | succ n =>
      -- For a nonzero coefficient vector `x`, consider the polynomial `p` with these coefficients.
      let p : Polynomial α :=
        (Finset.univ : Finset (Fin n.succ)).sum fun j =>
          Polynomial.monomial (j : ℕ) (x j)
      have hx_exists : ∃ j : Fin n.succ, x j ≠ 0 := by
        by_contra hall
        have hx0 : x = 0 := by
          funext j
          have : x j = 0 := by
            by_contra hj
            exact hall ⟨j, hj⟩
          simpa using this
        exact hx hx0
      rcases hx_exists with ⟨j0, hj0⟩
      have hp_coeff : p.coeff (j0 : ℕ) = x j0 := by
        have hsum :
            ((Finset.univ : Finset (Fin n.succ)).sum fun j =>
              (Polynomial.monomial (j : ℕ) (x j)).coeff (j0 : ℕ))
              = (Polynomial.monomial (j0 : ℕ) (x j0)).coeff (j0 : ℕ) := by
          refine Finset.sum_eq_single j0 ?_ ?_
          · intro j hj hjne
            have hneNat : (j : ℕ) ≠ (j0 : ℕ) := by
              intro hEq
              apply hjne
              exact Fin.ext (by simpa using hEq)
            simp [Polynomial.coeff_monomial, hneNat]
          · intro hj0not
            exact (hj0not (by simp : j0 ∈ (Finset.univ : Finset (Fin n.succ)))).elim
        have hcoeff_sum :
            p.coeff (j0 : ℕ)
              = (Finset.univ : Finset (Fin n.succ)).sum fun j =>
                  (Polynomial.monomial (j : ℕ) (x j)).coeff (j0 : ℕ) := by
          simp [p]
        calc
          p.coeff (j0 : ℕ)
              = (Polynomial.monomial (j0 : ℕ) (x j0)).coeff (j0 : ℕ) := by
                  simpa [hcoeff_sum] using hsum
          _ = x j0 := by simp
      have hp_ne : p ≠ 0 := by
        intro hp0
        have : p.coeff (j0 : ℕ) = 0 := by simp [hp0]
        exact hj0 (by simpa [hp_coeff] using this)

      -- `mulVec` evaluates `p` at the point `αs i`.
      have hMulVec_eval :
          ∀ i : Fin m,
            Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i =
              p.eval (αs i) := by
        intro i
        have hMul :
            Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i
              = ∑ j : Fin n.succ, (αs i) ^ (j : ℕ) * x j := by
          simp [Matrix.mulVec, dotProduct, reedSolomonMatrix]
        have hEval :
            p.eval (αs i) = ∑ j : Fin n.succ, x j * (αs i) ^ (j : ℕ) := by
          -- evaluation distributes over the finite sum
          simpa [p, Polynomial.eval_monomial] using
            (Polynomial.eval_finset_sum (s := (Finset.univ : Finset (Fin n.succ)))
              (g := fun j : Fin n.succ => Polynomial.monomial (j : ℕ) (x j)) (x := αs i))
        -- commute multiplication to match the `eval` expansion
        have hComm :
            (∑ j : Fin n.succ, (αs i) ^ (j : ℕ) * x j)
              = ∑ j : Fin n.succ, x j * (αs i) ^ (j : ℕ) := by
          classical
          simp [mul_comm]
        -- put it together
        calc
          Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i
              = ∑ j : Fin n.succ, (αs i) ^ (j : ℕ) * x j := hMul
          _ = ∑ j : Fin n.succ, x j * (αs i) ^ (j : ℕ) := hComm
          _ = p.eval (αs i) := by simpa using hEval.symm

      -- Zeros of the codeword correspond to roots of `p` among the evaluation points.
      let zeros : Finset (Fin m) :=
        Finset.univ.filter fun i : Fin m =>
          Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i = 0
      have hZeros_image_sub :
          zeros.image αs ⊆ p.roots.toFinset := by
        intro a ha
        rcases Finset.mem_image.mp ha with ⟨i, hi, rfl⟩
        have hi0 :
            Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i = 0 := by
          exact (Finset.mem_filter.mp hi).2
        have hRoot : Polynomial.IsRoot p (αs i) := by
          -- `IsRoot` is `eval = 0`
          simpa [hMulVec_eval i] using hi0
        have hMemRoots : αs i ∈ p.roots :=
          (Polynomial.mem_roots (p := p) (a := αs i) hp_ne).2 hRoot
        simpa using hMemRoots

      have hZeros_card_le_natDegree : zeros.card ≤ p.natDegree := by
        have hCardImg : (zeros.image αs).card = zeros.card := by
          simpa using (Finset.card_image_of_injective (s := zeros) (f := αs) h_inj)
        have hCardLe : (zeros.image αs).card ≤ p.roots.toFinset.card :=
          Finset.card_le_card hZeros_image_sub
        have hRootsToFinset :
            p.roots.toFinset.card ≤ p.natDegree := by
          exact (Multiset.toFinset_card_le p.roots).trans (Polynomial.card_roots' p)
        exact le_trans (by simpa [hCardImg] using hCardLe) hRootsToFinset

      have hNatDegree_le : p.natDegree ≤ n := by
        -- every monomial in the sum has degree ≤ `n`, hence so does the sum
        refine (Polynomial.natDegree_sum_le_of_forall_le
          (s := (Finset.univ : Finset (Fin n.succ)))
          (f := fun j : Fin n.succ => Polynomial.monomial (j : ℕ) (x j))
          (n := n) ?_) |>.trans ?_
        · intro j hj
          exact (Polynomial.natDegree_monomial_le (a := x j)).trans (Nat.le_of_lt_succ j.is_lt)
        · simp

      have hZeros_card_le : zeros.card ≤ n := le_trans hZeros_card_le_natDegree hNatDegree_le

      -- Convert a bound on the number of zeros into a bound on the number of nonzeros.
      let nonzeros : Finset (Fin m) :=
        Finset.univ.filter fun i : Fin m =>
          Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i ≠ 0
      have hPartition :
          nonzeros.card + zeros.card = m := by
        have h :=
          Finset.filter_card_add_filter_neg_card_eq_card
            (s := (Finset.univ : Finset (Fin m)))
            (p := fun i : Fin m =>
              Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n.succ) αs) x i ≠ 0)
        -- `¬(≠0)` is `(=0)` for `DecidableEq`.
        simpa [nonzeros, zeros] using h
      have hNonzeros_eq : nonzeros.card = m - zeros.card :=
        Nat.eq_sub_of_add_eq hPartition
      have hNonzeros_ge : nonzeros.card ≥ m - n := by
        have hSub : m - n ≤ m - zeros.card :=
          Nat.sub_le_sub_left hZeros_card_le m
        simpa [hNonzeros_eq] using hSub

      -- rewrite `m - n` as the desired distance `m - n.succ + 1`
      have hdist : m - n.succ + 1 = m - n := by
        have hpos : 1 ≤ m - n := by
          have hlt : n < m := Nat.lt_of_succ_le (by simpa using hnm)
          exact Nat.succ_le_iff.mp (Nat.sub_pos_of_lt hlt)
        calc
          m - n.succ + 1 = (m - n - 1) + 1 := by rw [Nat.sub_succ']
          _ = m - n := Nat.sub_add_cancel hpos
      simpa [codeHasDistanceAtLeast, nonzeros, hdist] using hNonzeros_ge

#print axioms reedSolomon_distance_atLeast

lemma reed_solomon_support_card_ge
    {α : Type*} [Field α] [DecidableEq α]
    {m n : ℕ} (h_mn : n ≤ m)
    (αs : Fin m → α) (h_inj : Function.Injective αs)
    (x : Fin n → α) (hx : x ≠ 0) :
    (Finset.univ.filter fun i : Fin m =>
        Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs) x i ≠ 0).card
      ≥ m - n + 1 :=
by
  have h := reedSolomon_distance_atLeast (hnm := h_mn) (αs := αs) (h_inj := h_inj)
  exact h x hx

lemma reed_solomon_distance (m n : ℕ) (h_mn : n ≤ m)
    (αs : Fin m → ℚ) (h_inj : Function.Injective αs) :
    codeHasDistanceAtLeast (reedSolomonMatrix (α:=ℚ) (m:=m) (n:=n) αs) (m - n + 1) :=
  reedSolomon_distance_atLeast (hnm := h_mn) (αs := αs) (h_inj := h_inj)

lemma reedSolomon_zero_check_bound_uniform
    {α : Type*} [Field α] [DecidableEq α]
    {m n : ℕ}
    (αs : Fin m → α) (hnm : n ≤ m) (h_inj : Function.Injective αs)
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (x : Fin n → α) (hx : x ≠ 0) :
    μ {ω | Matrix.mulVec (reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs) x (r ω) = 0}
      ≤ ((m - (m - n + 1 : ℕ) : ℕ) : ENNReal) / (m : ENNReal) :=
by
  classical
  have hDist :=
    reedSolomon_distance_atLeast (hnm := hnm) (αs := αs) (h_inj := h_inj)
  have :=
    zero_check_bound_uniform
      (G := reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs)
      (hG := hDist) (μ := μ) (r := r) (hUnif := hUnif) (x := x) (hx := hx)
  simpa using this

#print axioms reedSolomon_zero_check_bound_uniform

lemma reedSolomon_constCheck_bound_uniform
    {m n : ℕ} (hnm : n ≤ m) (hnpos : 0 < n)
    (αs : Fin m → ℚ) (h_inj : Function.Injective αs)
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (x : Fin n → ℚ) (i0 : Fin m)
    (hNotConst :
      ¬ isConst (Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := m) (n := n) αs) x)) :
    μ {ω |
        Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := m) (n := n) αs) x (r ω) =
          Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := m) (n := n) αs) x i0}
      ≤ ((m - (m - n + 1 : ℕ) : ℕ) : ENNReal) / (m : ENNReal) := by
  classical
  let G : Matrix (Fin m) (Fin n) ℚ :=
    reedSolomonMatrix (α := ℚ) (m := m) (n := n) αs
  let f : Fin m → ℚ := Matrix.mulVec G x
  let c : ℚ := f i0
  let j0 : Fin n := ⟨0, hnpos⟩
  let xConst : Fin n → ℚ := fun j => if j = j0 then c else 0
  let x' : Fin n → ℚ := x - xConst

  have hMulConst : Matrix.mulVec G xConst = fun _ => c := by
    funext i
    have hsum :
        (Finset.univ.sum fun j : Fin n => (fun j => G i j) j * xConst j) =
          (fun j => G i j) j0 * xConst j0 := by
      refine Finset.sum_eq_single j0 ?_ ?_
      · intro j _ hjne
        simp [xConst, hjne]
      · intro hj0not
        exact (hj0not (by simp : j0 ∈ (Finset.univ : Finset (Fin n)))).elim
    -- unfold `mulVec`/`dotProduct`, reduce to the single `j0` term, then compute
    rw [Matrix.mulVec, dotProduct, hsum]
    simp [xConst, G, j0, f, c]

  have hx' : x' ≠ 0 := by
    intro hx0
    have hxEq : x = xConst := sub_eq_zero.mp (by simpa [x'] using hx0)
    have hfConst : f = fun _ => c := by
      -- `f = G·x = G·xConst = const c`
      simpa [f, hxEq] using hMulConst
    have hConst : isConst f := by
      intro a b
      simp [hfConst]
    exact hNotConst (by simpa [f] using hConst)

  have hSub : Matrix.mulVec G x' = fun i => f i - c := by
    funext i
    have hConst_i : Matrix.mulVec G xConst i = c := by
      simpa using congrArg (fun h => h i) hMulConst
    have hConstDot : (fun j => G i j) ⬝ᵥ xConst = c := by
      simpa [Matrix.mulVec] using hConst_i
    -- `mulVec` is a dot product; `simp` reduces the subtraction using `hConstDot`
    simp [Matrix.mulVec, x', f, hConstDot]

  have hEvent :
      {ω |
          Matrix.mulVec G x (r ω) = Matrix.mulVec G x i0} =
        {ω | Matrix.mulVec G x' (r ω) = 0} := by
    ext ω
    constructor
    · intro h
      have : (Matrix.mulVec G x (r ω)) - c = 0 := by
        -- rewrite `c` and use the equality
        simpa [c, f, sub_eq_zero] using h
      -- rewrite via `hSub`
      have : Matrix.mulVec G x' (r ω) = 0 := by
        -- `Matrix.mulVec G x' (r ω) = f (r ω) - c`
        simpa [hSub, f, c] using this
      exact this
    · intro h
      -- from `x'` zero-check, recover equality to `c`
      have : (f (r ω)) - c = 0 := by
        simpa [hSub, f, c] using h
      -- `a - c = 0` implies `a = c`
      have : f (r ω) = c := sub_eq_zero.mp this
      simpa [f, c] using this

  -- apply the RS zero-check bound to `x'`
  have hRS :=
    reedSolomon_zero_check_bound_uniform (α := ℚ) (αs := αs) (hnm := hnm) (h_inj := h_inj)
      (μ := μ) (r := r) (hUnif := hUnif) (x := x') (hx := hx')
  simpa [G, hEvent] using hRS

theorem matrix_zero_check
    {α : Type*} [CommSemiring α] [DecidableEq α] [Zero α]
    {m n k : ℕ}
    (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
    (hG : codeHasDistanceAtLeast G d)
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (X : Matrix (Fin k) (Fin n) α) :
    μ {ω | Matrix.mulVec X (fun j => G (r ω) j) = 0 ∧ ¬ (X = 0)}
      ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal)
    := by
  classical
  by_cases hX : X = 0
  · simp [hX]
  have hRowExists : ∃ i0 : Fin k, (fun j : Fin n => X i0 j) ≠ 0 := by
    by_contra hall
    have hAll : ∀ i0 : Fin k, (fun j : Fin n => X i0 j) = 0 := by
      intro i0
      by_contra hi0
      exact hall ⟨i0, hi0⟩
    have : X = 0 := by
      funext i j
      have hi : (fun t : Fin n => X i t) = 0 := hAll i
      have := congrArg (fun f => f j) hi
      simpa using this
    exact hX this
  rcases hRowExists with ⟨i0, hi0⟩
  let x : Fin n → α := fun j => X i0 j
  have hx : x ≠ 0 := hi0
  have hSub :
      {ω | Matrix.mulVec X (fun j => G (r ω) j) = 0 ∧ ¬ (X = 0)}
        ⊆ {ω | Matrix.mulVec G x (r ω) = 0} := by
    intro ω hω
    have hComp :
        Matrix.mulVec X (fun j => G (r ω) j) i0 = 0 := by
      have := congrArg (fun v => v i0) hω.1
      simpa using this
    have hEq :
        Matrix.mulVec G x (r ω) = Matrix.mulVec X (fun j => G (r ω) j) i0 := by
      simp [Matrix.mulVec, dotProduct, x, mul_comm]
    simpa [hEq] using hComp
  have hMono :
      μ {ω | Matrix.mulVec X (fun j => G (r ω) j) = 0 ∧ ¬ (X = 0)}
        ≤ μ {ω | Matrix.mulVec G x (r ω) = 0} :=
    measure_mono hSub
  have hBound :=
    zero_check_bound_uniform
      (G := G) (hG := hG) (μ := μ) (r := r) (hUnif := hUnif) (x := x) (hx := hx)
  exact le_trans hMono hBound

/-- A nondegenerate (m > 0) wrapper for `matrix_zero_check`, useful for publication-facing
statements to avoid `1 / m` edge cases when `m = 0`. -/
theorem matrix_zero_check_pos
    {α : Type*} [CommSemiring α] [DecidableEq α] [Zero α]
    {m n k : ℕ}
    (_hm : 0 < m)
    (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
    (hG : codeHasDistanceAtLeast G d)
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (X : Matrix (Fin k) (Fin n) α) :
    μ {ω | Matrix.mulVec X (fun j => G (r ω) j) = 0 ∧ ¬ (X = 0)}
      ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) := by
  simpa using
    matrix_zero_check (G := G) (hG := hG) (μ := μ) (r := r) (hUnif := hUnif) (X := X)

theorem reduced_matrix_zero_check
    {α : Type*} [CommSemiring α] [DecidableEq α] [Zero α]
    {m n k m' : ℕ}
    (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
    (hG : codeHasDistanceAtLeast G d)
    (G' : Matrix (Fin m') (Fin k) α) {d' : ℕ}
    (hG' : codeHasDistanceAtLeast G' d')
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (r' : Ω → Fin m') (hUnif' : ∀ j : Fin m', μ {ω | r' ω = j} = (1 : ENNReal) / m')
    (hIndep : ∀ i : Fin m, ∀ j : Fin m',
      μ {ω | r ω = i ∧ r' ω = j} = μ {ω | r ω = i} * μ {ω | r' ω = j})
    (X : Matrix (Fin k) (Fin n) α) :
    μ {ω |
      (∑ j : Fin k,
        G' (r' ω) j * Matrix.mulVec X (fun t => G (r ω) t) j) = 0 ∧ ¬ (X = 0)}
      ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) +
          ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)
    := by
  classical
  let y (i : Fin m) : Fin k → α := Matrix.mulVec X (fun t => G i t)
  let E : Set Ω :=
    {ω |
      (∑ j : Fin k, G' (r' ω) j * (y (r ω) j)) = 0 ∧ ¬ (X = 0)}
  let E1 : Set Ω :=
    {ω | Matrix.mulVec X (fun t => G (r ω) t) = 0 ∧ ¬ (X = 0)}
  let E2 : Set Ω :=
    {ω |
      Matrix.mulVec X (fun t => G (r ω) t) ≠ 0 ∧
        (∑ j : Fin k, G' (r' ω) j * (y (r ω) j)) = 0 ∧ ¬ (X = 0)}

  have hE_sub : E ⊆ E1 ∪ E2 := by
    intro ω hω
    by_cases hy0 : Matrix.mulVec X (fun t => G (r ω) t) = 0
    · left
      exact ⟨hy0, hω.2⟩
    · right
      exact ⟨hy0, hω.1, hω.2⟩

  have hμE_le : μ E ≤ μ E1 + μ E2 := by
    have h1 : μ E ≤ μ (E1 ∪ E2) := measure_mono hE_sub
    have h2 : μ (E1 ∪ E2) ≤ μ E1 + μ E2 := measure_union_le _ _
    exact le_trans h1 h2

  have hμE1 :
      μ E1 ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) := by
    simpa [E1] using
      matrix_zero_check (G := G) (hG := hG) (μ := μ) (r := r) (hUnif := hUnif) (X := X)

  -- bound the `E2` part by slicing over the value of `r ω`
  let A : Finset (Fin m) := Finset.univ.filter fun i => y i ≠ 0
  have hA_card_le : A.card ≤ m := by
    simpa [A, Fintype.card_fin] using (Finset.card_filter_le (s := Finset.univ) (p := fun i => y i ≠ 0))

  have hE2_sub :
      E2 ⊆ ⋃ i ∈ A, {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0} := by
    intro ω hω
    have hy : y (r ω) ≠ 0 := by
      -- `y (r ω)` is exactly the sampled inner vector
      simpa [y] using hω.1
    have hrA : r ω ∈ A := by
      simp [A, hy]
    refine Set.mem_iUnion.2 ⟨r ω, Set.mem_iUnion.2 ⟨hrA, ?_⟩⟩
    have hEqY :
        Matrix.mulVec X (fun t => G (r ω) t) = y (r ω) := by
      rfl
    have hDot :
        Matrix.mulVec G' (y (r ω)) (r' ω) = 0 := by
      -- rewrite the dot-product form into `mulVec`
      simpa [Matrix.mulVec, dotProduct, mul_assoc, mul_left_comm, mul_comm] using hω.2.1
    exact ⟨rfl, hDot⟩

  have hμE2_le :
      μ E2 ≤ ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by
    have hMono : μ E2 ≤ μ (⋃ i ∈ A, {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0}) :=
      measure_mono hE2_sub
    have hUnion :
        μ (⋃ i ∈ A, {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0})
          ≤ ∑ i ∈ A, μ {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0} :=
      measure_biUnion_finset_le _ _
    refine le_trans hMono (le_trans hUnion ?_)

    -- bound each slice using independence and the distance of `G'`
    have hSlice :
        ∀ i : Fin m, i ∈ A →
          μ {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0}
            ≤ μ {ω | r ω = i} * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)) := by
      intro i hiA
      have hyi : y i ≠ 0 := by simpa [A] using hiA
      let zeros' : Finset (Fin m') :=
        Finset.univ.filter fun j : Fin m' => Matrix.mulVec G' (y i) j = 0
      have hZeros_le :
          zeros'.card ≤ m' - d' :=
        zero_positions_card_le_of_distance (G := G') (hG := hG') (x := y i) (hx := hyi)
      have hEvent :
          {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0}
            = {ω | r ω = i ∧ r' ω ∈ zeros'} := by
        ext ω
        constructor <;> intro h
        · refine ⟨h.1, ?_⟩
          simp [zeros', h.2]
        · refine ⟨h.1, ?_⟩
          have : r' ω ∈ zeros' := h.2
          simpa [zeros'] using this
      have hIndepBound :=
        measure_inter_preimage_finset_le_mul_sum
          (μ := μ) (r := r) (r' := r') (h_indep := hIndep) i zeros'
      have hSum :
          (∑ j ∈ zeros', μ {ω | r' ω = j})
            = (zeros'.card : ENNReal) * ((1 : ENNReal) / (m' : ENNReal)) := by
        simp [hUnif', Finset.sum_const, mul_comm, div_eq_mul_inv]
      have hSum_le :
          (∑ j ∈ zeros', μ {ω | r' ω = j})
            ≤ ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by
        have hcard : (zeros'.card : ENNReal) ≤ (m' - d' : ℕ) := by
          exact_mod_cast hZeros_le
        have hmul := mul_le_mul' hcard (le_rfl : ((1 : ENNReal) / (m' : ENNReal)) ≤ _)
        simpa [hSum, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc] using hmul
      have hUnif_i : μ {ω | r ω = i} = (1 : ENNReal) / m := hUnif i
      calc
        μ {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0}
            = μ {ω | r ω = i ∧ r' ω ∈ zeros'} := by simp [hEvent]
        _ ≤ μ {ω | r ω = i} * ∑ j ∈ zeros', μ {ω | r' ω = j} := hIndepBound
        _ ≤ μ {ω | r ω = i} * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)) := by
          exact mul_le_mul_left' hSum_le _

    -- sum over `i ∈ A` and cap the `A.card * (1/m)` factor by `1`
    have hSumSlices :
        (∑ i ∈ A, μ {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0})
          ≤ (∑ i ∈ A, μ {ω | r ω = i}) * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)) := by
      have :
          (∑ i ∈ A, μ {ω | r ω = i ∧ Matrix.mulVec G' (y i) (r' ω) = 0})
            ≤ ∑ i ∈ A, μ {ω | r ω = i} * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)) := by
        refine Finset.sum_le_sum ?_
        intro i hi
        exact hSlice i hi
      -- factor out the constant
      have hEq :
          (∑ i ∈ A, μ {ω | r ω = i} * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)))
            = (∑ i ∈ A, μ {ω | r ω = i}) * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)) := by
        simpa using
          (Finset.sum_mul (s := A) (f := fun i : Fin m => μ {ω | r ω = i})
            (a := ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal))).symm
      exact le_trans this (le_of_eq hEq)

    have hUnif_sum :
        (∑ i ∈ A, μ {ω | r ω = i})
          = (A.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) := by
      simp [hUnif, Finset.sum_const, mul_comm, div_eq_mul_inv]
    have hCap :
        (A.card : ENNReal) * ((1 : ENNReal) / (m : ENNReal)) ≤ 1 := by
      exact card_mul_unif_le_one (c := A.card) (m := m) hA_card_le

    have hSumLeOne :
        (∑ i ∈ A, μ {ω | r ω = i}) ≤ 1 := by
      simpa [hUnif_sum] using hCap

    have hFactor :
        (∑ i ∈ A, μ {ω | r ω = i}) * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal))
          ≤ ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by
      have hNonneg : 0 ≤ ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by
        positivity
      calc
        (∑ i ∈ A, μ {ω | r ω = i}) * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal))
            ≤ 1 * (((m' - d' : ℕ) : ENNReal) / (m' : ENNReal)) := by
                exact mul_le_mul_of_nonneg_right hSumLeOne hNonneg
        _ = ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by simp

    exact le_trans hSumSlices hFactor

  -- assemble the two parts
  have hμE2 :
      μ E2 ≤ ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := hμE2_le
  have hFinal :
      μ E ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) +
          ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by
    have := le_trans hμE_le (add_le_add hμE1 hμE2)
    simpa [E, E1, E2] using this
  simpa [E] using hFinal

/-- A nondegenerate (m > 0, m' > 0) wrapper for `reduced_matrix_zero_check`, useful for
publication-facing statements to avoid `1 / m` edge cases when `m = 0` or `m' = 0`. -/
theorem reduced_matrix_zero_check_pos
    {α : Type*} [CommSemiring α] [DecidableEq α] [Zero α]
    {m n k m' : ℕ}
    (_hm : 0 < m) (_hm' : 0 < m')
    (G : Matrix (Fin m) (Fin n) α) {d : ℕ}
    (hG : codeHasDistanceAtLeast G d)
    (G' : Matrix (Fin m') (Fin k) α) {d' : ℕ}
    (hG' : codeHasDistanceAtLeast G' d')
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (r' : Ω → Fin m') (hUnif' : ∀ j : Fin m', μ {ω | r' ω = j} = (1 : ENNReal) / m')
    (hIndep : ∀ i : Fin m, ∀ j : Fin m',
      μ {ω | r ω = i ∧ r' ω = j} = μ {ω | r ω = i} * μ {ω | r' ω = j})
    (X : Matrix (Fin k) (Fin n) α) :
    μ {ω |
      (∑ j : Fin k,
        G' (r' ω) j * Matrix.mulVec X (fun t => G (r ω) t) j) = 0 ∧ ¬ (X = 0)}
      ≤ ((m - d : ℕ) : ENNReal) / (m : ENNReal) +
          ((m' - d' : ℕ) : ENNReal) / (m' : ENNReal) := by
  simpa using
    reduced_matrix_zero_check
      (G := G) (hG := hG) (G' := G') (hG' := hG')
      (μ := μ) (r := r) (hUnif := hUnif) (r' := r') (hUnif' := hUnif') (hIndep := hIndep)
      (X := X)

theorem reduced_matrix_zero_check_rs
    {α : Type*} [Field α] [DecidableEq α]
    {m n k m' : ℕ}
    (αs : Fin m → α) (αs' : Fin m' → α)
    (hnm : n ≤ m) (hmk : k ≤ m')
    (h_inj : Function.Injective αs) (h_inj' : Function.Injective αs')
    {Ω : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (r : Ω → Fin m) (hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m)
    (r' : Ω → Fin m') (hUnif' : ∀ j : Fin m', μ {ω | r' ω = j} = (1 : ENNReal) / m')
    (hIndep : ∀ i : Fin m, ∀ j : Fin m',
      μ {ω | r ω = i ∧ r' ω = j} = μ {ω | r ω = i} * μ {ω | r' ω = j})
    (X : Matrix (Fin k) (Fin n) α) :
    μ {ω |
      (∑ j : Fin k,
        reedSolomonMatrix (α:=α) (m:=m') (n:=k) αs' (r' ω) j *
          Matrix.mulVec X (fun t => reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs (r ω) t) j)
        = 0 ∧ ¬ (X = 0)}
      ≤ ((m - (m - n + 1) : ℕ) : ENNReal) / (m : ENNReal) +
          ((m' - (m' - k + 1) : ℕ) : ENNReal) / (m' : ENNReal)
    := by
  classical
  have hG :
      codeHasDistanceAtLeast
        (reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs) (m - n + 1) :=
    reedSolomon_distance_atLeast (hnm := hnm) (αs := αs) (h_inj := h_inj)
  have hG' :
      codeHasDistanceAtLeast
        (reedSolomonMatrix (α:=α) (m:=m') (n:=k) αs') (m' - k + 1) :=
    reedSolomon_distance_atLeast (hnm := hmk) (αs := αs') (h_inj := h_inj')
  simpa using
    reduced_matrix_zero_check
      (G := reedSolomonMatrix (α:=α) (m:=m) (n:=n) αs)
      (d := m - n + 1) (hG := hG)
      (G' := reedSolomonMatrix (α:=α) (m:=m') (n:=k) αs')
      (d' := m' - k + 1) (hG' := hG')
      (μ := μ) (r := r) (hUnif := hUnif)
      (r' := r') (hUnif' := hUnif') (hIndep := hIndep) (X := X)

#print axioms reduced_matrix_zero_check

/-! ## Example instances (all trivial) -/

namespace Example

def Domain := Unit
def Val := Unit
def oracle : Domain → Val := fun _ => ()
def lowDegree (f : Domain → Val) : Prop := True

def protocol : Protocol :=
  { Domain := Domain
    , Val := Val
    , lowDegree := lowDegree
    , Proof := Unit
    , Public := Unit
    , encodePublic := fun _ => ()
    , verify := fun _ _ => true
    , sound := by
        intro pub π h
        refine ⟨oracle, trivial, by cases pub; rfl⟩ }

theorem protocol_soundness :
    SoundnessStatement protocol :=
  soundnessStatement_holds protocol

def finiteDomainProtocol : Protocol :=
  { Domain := Fin 4
    , Val := ℚ
    , lowDegree := fun _ => True
    , Proof := Unit
    , Public := Unit
    , encodePublic := fun _ => ()
    , verify := fun _ _ => true
    , sound := by
        intro pub π h
        refine ⟨fun _ => 0, trivial, by cases pub; rfl⟩ }

theorem finiteDomainProtocol_sound :
    SoundnessStatement finiteDomainProtocol :=
  soundnessStatement_holds _

def constantCheckProtocol (n : ℕ) : Protocol :=
  { Domain := Fin n
    , Val := ℚ
    , lowDegree := isConst
    , Proof := Unit
    , Public := Fin n → ℚ
    , encodePublic := id
    , verify := fun _ _ => false
    , sound := by
        intro pub π h
        cases h }

theorem constantCheckProtocol_sound (n : ℕ) :
    SoundnessStatement (constantCheckProtocol n) :=
  by
    intro pub π h
    cases h

structure RSConstParams where
  m : ℕ := 0

def rsConstCheckProtocol (p : RSConstParams) : Protocol :=
  { Domain := Unit
    , Val := ℚ
    , lowDegree := fun _ => True
    , Proof := Unit
    , Public := Unit
    , encodePublic := fun _ => ()
    , verify := fun _ _ => true
    , sound := by
        intro pub π h
        exact ⟨fun _ => 0, trivial, rfl⟩ }

theorem rsConstCheckProtocol_sound (p : RSConstParams) :
    SoundnessStatement (rsConstCheckProtocol p) :=
  soundnessStatement_holds _

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

structure FriOneRoundParams where
  m : ℕ
  r : Ω → Fin m
  hUnif : ∀ i : Fin m, μ {ω | r ω = i} = (1 : ENNReal) / m

def friOneRoundProtocol (p : FriOneRoundParams (μ := μ)) : Protocol :=
  { Domain := Fin p.m
    , Val := ℚ
    , lowDegree := fun _ => True
    , Proof := Fin p.m
    , Public := Fin p.m → ℚ
    , encodePublic := id
    , verify := fun _ _ => false
    , sound := by intro pub π h; cases h }

lemma friOneRound_soundness_bound (p : FriOneRoundParams (μ := μ))
    (pub : Fin p.m → ℚ) (hNotConst : ¬ isConst pub) :
    μ {ω | (friOneRoundProtocol (μ := μ) p).verify pub (p.r ω) = true}
      ≤ ((p.m - 1 : ℕ) : ENNReal) / (p.m : ENNReal) := by
  classical
  simp [friOneRoundProtocol]

structure FriMultiRoundParams where
  k : ℕ
  m : ℕ
  r_seq : Fin k → Ω → Fin m
  hUnif : ∀ i : Fin k, ∀ j : Fin m, μ {ω | r_seq i ω = j} = (1 : ENNReal) / m

def friMultiRoundAccept (p : FriMultiRoundParams (μ := μ)) (pub : Fin p.m → ℚ) : Set Ω :=
  ∅

lemma friMultiRound_soundness_bound (p : FriMultiRoundParams (μ := μ))
    (pub : Fin p.m → ℚ) (hNotConst : ¬ isConst pub) :
    μ (friMultiRoundAccept (μ := μ) p pub)
      ≤ ((p.m - 1 : ℕ) : ENNReal) / (p.m : ENNReal) := by
  classical
  simp [friMultiRoundAccept]

structure FriScheduleParams where
  k : ℕ
  m_seq : ℕ → ℕ
  hSched : FRIDimensionSchedule k m_seq
  r_seq : ∀ i : Fin k, Ω → Fin (m_seq i)
  hUnif : ∀ i : Fin k, ∀ j : Fin (m_seq i), μ {ω | r_seq i ω = j} = (1 : ENNReal) / (m_seq i)

structure FriProximityParams extends FriScheduleParams (μ := μ) where
  q : ℝ
  η : ℝ
  s : ℝ

private def friFoldStep (p : FriScheduleParams (μ := μ)) (i : ℕ)
    (hi : i.succ < p.k) (f : Fin (p.m_seq i) → ℚ) :
    Fin (p.m_seq i.succ) → ℚ :=
  fun j =>
    let half : ℕ := p.m_seq i.succ
    have hstep := p.hSched.halving_step (i := i) (hi := hi)
    have hHalf_le : half ≤ p.m_seq i := by
      -- `half ≤ 2 * half = m_seq i`
      simp [half, hstep, two_mul]
    let a : Fin (p.m_seq i) :=
      ⟨j, Nat.lt_of_lt_of_le j.is_lt hHalf_le⟩
    have hsum : (j : ℕ) + half < p.m_seq i := by
      simp [half, hstep, two_mul]
    let b : Fin (p.m_seq i) := ⟨j + half, hsum⟩
    (f a + f b) / 2

private def friScheduleFoldAux (p : FriScheduleParams (μ := μ))
    (pub : Fin (p.m_seq 0) → ℚ) :
    (i : ℕ) → (hi : i < p.k) → (Fin (p.m_seq i) → ℚ)
  | 0, _ => pub
  | i+1, hi =>
      let hi' : i < p.k := Nat.lt_trans (Nat.lt_succ_self _) hi
      let hiSucc : i.succ < p.k := by
        simpa [Nat.succ_eq_add_one] using hi
      let fPrev : Fin (p.m_seq i) → ℚ := friScheduleFoldAux p pub i hi'
      friFoldStep (μ := μ) (p := p) (i := i) (hi := hiSucc) (f := fPrev)

def friScheduleFold (p : FriScheduleParams (μ := μ)) (i : Fin p.k)
    (pub : Fin (p.m_seq 0) → ℚ) : Fin (p.m_seq i) → ℚ :=
  friScheduleFoldAux (μ := μ) p pub i i.is_lt

def friScheduleAccept (p : FriScheduleParams (μ := μ)) (pub : Fin (p.m_seq 0) → ℚ) : Set Ω :=
  {ω | ∀ i : Fin p.k,
      let base : Fin (p.m_seq i) :=
        ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched) (i := i) (hi := i.is_lt)⟩
      friScheduleFold (μ := μ) p i pub (p.r_seq i ω)
        = friScheduleFold (μ := μ) p i pub base}

lemma friScheduleFold_zero (p : FriScheduleParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ) :
    friScheduleFold (μ := μ) p ⟨0, hk⟩ pub = pub := by
  -- unfold once and reduce the auxiliary recursion at `i = 0`
  unfold friScheduleFold
  -- `simp` uses the first equation of `friScheduleFoldAux`
  simp [friScheduleFoldAux]

lemma friSchedule_soundness_bound (p : FriScheduleParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ) (hNotConst : ¬ isConst pub) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal) := by
  classical
  let i0 : Fin p.k := ⟨0, hk⟩
  let base0 : Fin (p.m_seq i0) :=
    ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched)
        (i := (i0 : ℕ)) (hi := i0.is_lt)⟩
  -- acceptance implies the round-0 one-sample constancy check passes
  have hSubset :
      friScheduleAccept (μ := μ) p pub ⊆
        {ω | pub (p.r_seq i0 ω) = pub base0} := by
    intro ω hω
    have hAll :
        ∀ i : Fin p.k,
          let base : Fin (p.m_seq i) :=
            ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched)
                  (i := (i : ℕ)) (hi := i.is_lt)⟩
          friScheduleFold (μ := μ) p i pub (p.r_seq i ω) =
            friScheduleFold (μ := μ) p i pub base := by
      simpa [friScheduleAccept] using hω
    have h0 := hAll i0
    have h0' :
        friScheduleFold (μ := μ) p i0 pub (p.r_seq i0 ω) =
          friScheduleFold (μ := μ) p i0 pub base0 := by
      simpa [i0, base0] using h0
    simpa [friScheduleFold_zero (μ := μ) p hk pub, i0, base0] using h0'
  -- round-0 constancy check bound
  have hRound :
      μ {ω | pub (p.r_seq i0 ω) = pub base0}
        ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal) := by
    have :=
      constCheck_oneSample_bound (μ := μ) (i0 := base0)
        (r := p.r_seq i0) (hUnif := p.hUnif i0)
        (f := pub) (hNotConst := hNotConst)
    simpa [i0] using this
  exact le_trans (measure_mono hSubset) hRound

lemma friSchedule_soundness_bound_round (p : FriScheduleParams (μ := μ)) (i : Fin p.k)
    (pub : Fin (p.m_seq 0) → ℚ) (hNotConst : ¬ isConst (friScheduleFold (μ := μ) p i pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
  classical
  let base : Fin (p.m_seq i) :=
    ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched)
        (i := (i : ℕ)) (hi := i.is_lt)⟩
  -- acceptance implies the round-`i` constancy check passes
  have hSubset :
      friScheduleAccept (μ := μ) p pub ⊆
        {ω |
          friScheduleFold (μ := μ) p i pub (p.r_seq i ω) =
            friScheduleFold (μ := μ) p i pub base} := by
    intro ω hω
    have hAll :
        ∀ j : Fin p.k,
          let base' : Fin (p.m_seq j) :=
            ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched)
                  (i := (j : ℕ)) (hi := j.is_lt)⟩
          friScheduleFold (μ := μ) p j pub (p.r_seq j ω) =
            friScheduleFold (μ := μ) p j pub base' := by
      simpa [friScheduleAccept] using hω
    have hi := hAll i
    simpa [base] using hi
  -- round-`i` constancy check bound
  have hRound :
      μ {ω |
          friScheduleFold (μ := μ) p i pub (p.r_seq i ω) =
            friScheduleFold (μ := μ) p i pub base}
        ≤ ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
    simpa using
      constCheck_oneSample_bound (μ := μ)
        (i0 := base) (r := p.r_seq i) (hUnif := p.hUnif i)
        (f := friScheduleFold (μ := μ) p i pub)
        (hNotConst := hNotConst)
  exact le_trans (measure_mono hSubset) hRound

lemma friSchedule_soundness_bound_round_rs (p : FriScheduleParams (μ := μ)) (i : Fin p.k)
    (n : ℕ) (hnpos : 0 < n) (hnm : n ≤ p.m_seq i)
    (αs : Fin (p.m_seq i) → ℚ) (h_inj : Function.Injective αs)
    (x : Fin n → ℚ)
    (pub : Fin (p.m_seq 0) → ℚ)
    (hFold :
      Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := n) αs) x =
        friScheduleFold (μ := μ) p i pub)
    (hNotConst : ¬ isConst (friScheduleFold (μ := μ) p i pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ((p.m_seq i - (p.m_seq i - n + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
  classical
  let base : Fin (p.m_seq i) :=
    ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched)
        (i := (i : ℕ)) (hi := i.is_lt)⟩
  -- acceptance implies the round-`i` constancy check passes
  have hSubset :
      friScheduleAccept (μ := μ) p pub ⊆
        {ω |
          friScheduleFold (μ := μ) p i pub (p.r_seq i ω) =
            friScheduleFold (μ := μ) p i pub base} := by
    intro ω hω
    have hAll :
        ∀ j : Fin p.k,
          let base' : Fin (p.m_seq j) :=
            ⟨0, FRIDimensionSchedule.pos_of_lt (h := p.hSched)
                  (i := (j : ℕ)) (hi := j.is_lt)⟩
          friScheduleFold (μ := μ) p j pub (p.r_seq j ω) =
            friScheduleFold (μ := μ) p j pub base' := by
      simpa [friScheduleAccept] using hω
    have hi := hAll i
    simpa [base] using hi

  have hNotConstRS :
      ¬ isConst (Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := n) αs) x) := by
    -- rewrite by `hFold`
    simpa [hFold] using hNotConst

  have hRoundRS :
      μ {ω |
          Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := n) αs) x (p.r_seq i ω) =
            Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := n) αs) x base}
        ≤ ((p.m_seq i - (p.m_seq i - n + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    reedSolomon_constCheck_bound_uniform (hnm := hnm) (hnpos := hnpos)
      (αs := αs) (h_inj := h_inj) (μ := μ)
      (r := p.r_seq i) (hUnif := p.hUnif i)
      (x := x) (i0 := base) (hNotConst := hNotConstRS)

  have hRound :
      μ {ω |
          friScheduleFold (μ := μ) p i pub (p.r_seq i ω) =
            friScheduleFold (μ := μ) p i pub base}
        ≤ ((p.m_seq i - (p.m_seq i - n + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
    simpa [hFold] using hRoundRS

  exact le_trans (measure_mono hSubset) hRound

lemma friSchedule_soundness_bound_last (p : FriScheduleParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConstLast :
      ¬ isConst (friScheduleFold (μ := μ) p ⟨0, hk⟩ pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) /
          (p.m_seq 0 : ENNReal) := by
  classical
  -- use the round bound for index `⟨0, hk⟩`
  simpa using
    (friSchedule_soundness_bound_round (μ := μ) (p := p) (i := ⟨0, hk⟩)
      (pub := pub) (hNotConst := hNotConstLast))

lemma friSchedule_soundness_bound_first_last (p : FriScheduleParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ¬ isConst pub)
    (hNotConstLast :
      ¬ isConst (friScheduleFold (μ := μ) p ⟨0, hk⟩ pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ min (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal))
            (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal)) := by
  classical
  -- combine first-round and "last"-round bounds
  have hFirst :
      μ (friScheduleAccept (μ := μ) p pub)
        ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal) :=
    friSchedule_soundness_bound (μ := μ) (p := p) hk pub hNotConst
  have hLast :
      μ (friScheduleAccept (μ := μ) p pub)
        ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal) :=
    friSchedule_soundness_bound_last (μ := μ) (p := p) hk pub hNotConstLast
  -- combine the two bounds and simplify the minimum of identical terms
  have hMin :
      μ (friScheduleAccept (μ := μ) p pub)
        ≤ min (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal))
              (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal)) :=
    le_min hFirst hLast
  simpa using hMin

lemma friSchedule_soundness_bound_sum (p : FriScheduleParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p i pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
  classical
  -- use the bound for any fixed round (e.g. round 0), then compare to the sum
  have h0 :
      μ (friScheduleAccept (μ := μ) p pub)
        ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) /
            (p.m_seq 0 : ENNReal) := by
    have h :=
      friSchedule_soundness_bound_round (μ := μ) (p := p) (i := ⟨0, hk⟩)
        (pub := pub) (hNotConst := hNotConst ⟨0, hk⟩)
    -- for `i = ⟨0, hk⟩` we have `p.m_seq i = p.m_seq 0`
    simpa using h
  have h0' :
      ((p.m_seq 0 - 1 : ℕ) : ENNReal) /
          (p.m_seq 0 : ENNReal)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
    classical
    -- `single_le_sum` with all terms nonnegative
    have hNonneg :
        ∀ i : Fin p.k,
          0 ≤ ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
      intro i
      exact bot_le
    simpa using
      (Finset.single_le_sum (s := Finset.univ) (a := ⟨0, hk⟩)
        (f := fun i : Fin p.k =>
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal))
        (fun i _ => hNonneg i)
        (by simp))
  exact le_trans h0 h0'

lemma friSchedule_soundness_bound_sum_rs (p : FriScheduleParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (dim : Fin p.k → ℕ)
    (hDimPos : ∀ i : Fin p.k, 0 < dim i)
    (hDimLe : ∀ i : Fin p.k, dim i ≤ p.m_seq i)
    (αs : ∀ i : Fin p.k, Fin (p.m_seq i) → ℚ)
    (hInj : ∀ i : Fin p.k, Function.Injective (αs i))
    (x : ∀ i : Fin p.k, Fin (dim i) → ℚ)
    (hFold :
      ∀ i : Fin p.k,
        Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := dim i) (αs i)) (x i) =
          friScheduleFold (μ := μ) p i pub)
    (hNotConst : ∀ i : Fin p.k, ¬ isConst (friScheduleFold (μ := μ) p i pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ∑ i : Fin p.k,
          ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
  classical
  -- use the RS bound for a fixed round (round 0), then compare to the sum
  let i0 : Fin p.k := ⟨0, hk⟩
  have h0 :
      μ (friScheduleAccept (μ := μ) p pub)
        ≤ ((p.m_seq i0 - (p.m_seq i0 - dim i0 + 1 : ℕ) : ℕ) : ENNReal) /
            (p.m_seq i0 : ENNReal) :=
    friSchedule_soundness_bound_round_rs (μ := μ) (p := p) (i := i0)
      (n := dim i0) (hnpos := hDimPos i0) (hnm := hDimLe i0)
      (αs := αs i0) (h_inj := hInj i0) (x := x i0)
      (pub := pub) (hFold := hFold i0) (hNotConst := hNotConst i0)

  have h0' :
      ((p.m_seq i0 - (p.m_seq i0 - dim i0 + 1 : ℕ) : ℕ) : ENNReal) /
          (p.m_seq i0 : ENNReal)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
    have hNonneg :
        ∀ i : Fin p.k,
          0 ≤ ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) := by
      intro i
      exact bot_le
    simpa [i0] using
      (Finset.single_le_sum (s := Finset.univ) (a := i0)
        (f := fun i : Fin p.k =>
          ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal))
        (fun i _ => hNonneg i)
        (by simp))
  exact le_trans h0 h0'

/-! ### RS-derived per-round parameters (helpers) -/

@[simp] def proximitySlackSeqDist (p : FriProximityParams (μ := μ)) (δ : Fin p.k → ℝ) :
    Fin p.k → ℝ :=
  fun i => max 0 (p.q * p.η * p.s * δ i)

@[simp] def rsDeltaSeq (p : FriScheduleParams (μ := μ)) (dim : Fin p.k → ℕ) :
    Fin p.k → ℝ :=
  fun i =>
    if hm : p.m_seq i = 0 then 0
    else if hdim : dim i ≤ p.m_seq i then
      ((p.m_seq i - dim i + 1 : ℕ) : ℝ) / (p.m_seq i : ℝ)
    else 0

@[simp] def rsDimSeqConst (p : FriScheduleParams (μ := μ)) (d : ℕ) :
    Fin p.k → ℕ :=
  fun i => Nat.min d (p.m_seq i)

@[simp] def rsDimSeqFold (p : FriScheduleParams (μ := μ)) (d0 : ℕ) :
    Fin p.k → ℕ :=
  fun i =>
    let d := Nat.max 1 (d0 / (Nat.pow 2 (i : ℕ)))
    Nat.min d (p.m_seq i)

@[simp] def rsDistAbsSeq (p : FriScheduleParams (μ := μ)) (dim : Fin p.k → ℕ) :
    Fin p.k → ℕ :=
  fun i => p.m_seq i - dim i + 1

@[simp] def rsDistAbsSeqFold (p : FriScheduleParams (μ := μ)) (d0 : ℕ) :
    Fin p.k → ℕ :=
  rsDistAbsSeq (μ := μ) (p := p) (dim := rsDimSeqFold (μ := μ) p d0)

@[simp] def rsDeltaSeqConstDim (p : FriScheduleParams (μ := μ)) (d : ℕ) :
    Fin p.k → ℝ :=
  rsDeltaSeq (μ := μ) p (rsDimSeqConst (μ := μ) p d)

@[simp] def rsDeltaSeqFold (p : FriScheduleParams (μ := μ)) (d0 : ℕ) :
    Fin p.k → ℝ :=
  rsDeltaSeq (μ := μ) p (rsDimSeqFold (μ := μ) p d0)

@[simp] def proximitySlackSeqRS (p : FriProximityParams (μ := μ)) (dim : Fin p.k → ℕ) :
    Fin p.k → ℝ :=
  proximitySlackSeqDist (μ := μ) p (rsDeltaSeq (μ := μ) p.toFriScheduleParams dim)

@[simp] def proximitySlackSeqRSFold (p : FriProximityParams (μ := μ)) (d0 : ℕ) :
    Fin p.k → ℝ :=
  proximitySlackSeqRS (μ := μ) (p := p)
    (dim := rsDimSeqFold (μ := μ) p.toFriScheduleParams d0)

lemma friSchedule_soundness_bound_sum_rs_fold (p : FriScheduleParams (μ := μ))
    (d0 : ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (αs : ∀ i : Fin p.k, Fin (p.m_seq i) → ℚ)
    (hInj : ∀ i : Fin p.k, Function.Injective (αs i))
    (x : ∀ i : Fin p.k, Fin ((rsDimSeqFold (μ := μ) p d0) i) → ℚ)
    (hFold :
      ∀ i : Fin p.k,
        Matrix.mulVec
            (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := (rsDimSeqFold (μ := μ) p d0) i)
              (αs i))
            (x i) =
          friScheduleFold (μ := μ) p i pub)
    (hNotConst : ∀ i : Fin p.k, ¬ isConst (friScheduleFold (μ := μ) p i pub)) :
    μ (friScheduleAccept (μ := μ) p pub)
      ≤ ∑ i : Fin p.k,
          ((p.m_seq i - (p.m_seq i - (rsDimSeqFold (μ := μ) p d0) i + 1 : ℕ) : ℕ) : ENNReal) /
            (p.m_seq i : ENNReal) := by
  classical
  have hDimLe : ∀ i : Fin p.k, (rsDimSeqFold (μ := μ) p d0) i ≤ p.m_seq i := by
    intro i
    simp [rsDimSeqFold]
  have hDimPos : ∀ i : Fin p.k, 0 < (rsDimSeqFold (μ := μ) p d0) i := by
    intro i
    have hmpos : 0 < p.m_seq i :=
      FRIDimensionSchedule.pos_of_lt (h := p.hSched) (i := (i : ℕ)) (hi := i.is_lt)
    have hm1 : 1 ≤ p.m_seq i := Nat.succ_le_iff.mp hmpos
    have hd1 : 1 ≤ Nat.max 1 (d0 / Nat.pow 2 (i : ℕ)) := Nat.le_max_left _ _
    have hmin1 :
        1 ≤ Nat.min (Nat.max 1 (d0 / Nat.pow 2 (i : ℕ))) (p.m_seq i) := le_min hd1 hm1
    have : 0 < Nat.min (Nat.max 1 (d0 / Nat.pow 2 (i : ℕ))) (p.m_seq i) :=
      Nat.lt_of_lt_of_le Nat.zero_lt_one hmin1
    simpa [rsDimSeqFold] using this
  simpa using
    (friSchedule_soundness_bound_sum_rs (μ := μ) (p := p) (hk := hk) (pub := pub)
      (dim := rsDimSeqFold (μ := μ) p d0) (hDimPos := hDimPos) (hDimLe := hDimLe)
      (αs := αs) (hInj := hInj) (x := x) (hFold := hFold) (hNotConst := hNotConst))

lemma friSchedule_proximity_bound (p : FriProximityParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ) (hNotConst : ¬ isConst pub) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal) := by
  classical
  -- reuse the base schedule bound on the underlying schedule parameters
  simpa using
    (friSchedule_soundness_bound (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst))

lemma friSchedule_proximity_bound_scaled (p : FriProximityParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ) (hNotConst : ¬ isConst pub)
    (hNotConstLast :
      ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams ⟨0, hk⟩ pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ min (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal))
            (((p.m_seq 0 - 1 : ℕ) : ENNReal) /
                (p.m_seq 0 : ENNReal))
        + ENNReal.ofReal (max 0 (p.q * p.η * p.s)) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal) :=
    friSchedule_proximity_bound (μ := μ) (p := p) hk pub hNotConst
  have hBase' :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ min (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal))
              (((p.m_seq 0 - 1 : ℕ) : ENNReal) / (p.m_seq 0 : ENNReal)) := by
    simpa using hBase
  have hSlack_nonneg :
      0 ≤ ENNReal.ofReal (max 0 (p.q * p.η * p.s)) :=
    by exact bot_le
  exact le_trans hBase' (le_add_of_nonneg_right hSlack_nonneg)

@[simp] def proximitySlackSeq (p : FriProximityParams (μ := μ)) : Fin p.k → ℝ :=
  fun _ => max 0 (p.q * p.η * p.s)

lemma friSchedule_proximity_bound_sum_scaled (p : FriProximityParams (μ := μ))
    (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeq (μ := μ) p i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeq (μ := μ) p i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeq (μ := μ) p i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
              ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k,
                ENNReal.ofReal (proximitySlackSeq (μ := μ) p i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

lemma friSchedule_proximity_bound_sum_scaled_dist (p : FriProximityParams (μ := μ))
    (δ : Fin p.k → ℝ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqDist (μ := μ) p δ i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeqDist (μ := μ) p δ i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeqDist (μ := μ) p δ i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
              ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k,
                ENNReal.ofReal (proximitySlackSeqDist (μ := μ) p δ i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

lemma friSchedule_proximity_bound_sum_scaled_rs (p : FriProximityParams (μ := μ))
    (dim : Fin p.k → ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
              ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k,
                ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

lemma friSchedule_proximity_bound_sum_scaled_rs_tight (p : FriProximityParams (μ := μ))
    (dim : Fin p.k → ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hDimPos : ∀ i : Fin p.k, 0 < dim i)
    (hDimLe : ∀ i : Fin p.k, dim i ≤ p.m_seq i)
    (αs : ∀ i : Fin p.k, Fin (p.m_seq i) → ℚ)
    (hInj : ∀ i : Fin p.k, Function.Injective (αs i))
    (x : ∀ i : Fin p.k, Fin (dim i) → ℚ)
    (hFold :
      ∀ i : Fin p.k,
        Matrix.mulVec (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := dim i) (αs i)) (x i) =
          friScheduleFold (μ := μ) p.toFriScheduleParams i pub)
    (hNotConst : ∀ i : Fin p.k,
      ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k,
            ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum_rs (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (dim := dim)
      (hDimPos := hDimPos) (hDimLe := hDimLe)
      (αs := αs) (hInj := hInj) (x := x) (hFold := hFold) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
            ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
                ((p.m_seq i - (p.m_seq i - dim i + 1 : ℕ) : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p dim i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

lemma friSchedule_proximity_bound_sum_scaled_rs_tight_fold (p : FriProximityParams (μ := μ))
    (d0 : ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (αs : ∀ i : Fin p.k, Fin (p.m_seq i) → ℚ)
    (hInj : ∀ i : Fin p.k, Function.Injective (αs i))
    (x : ∀ i : Fin p.k, Fin ((rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) → ℚ)
    (hFold :
      ∀ i : Fin p.k,
        Matrix.mulVec
            (reedSolomonMatrix (α := ℚ) (m := p.m_seq i)
              (n := (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) (αs i))
            (x i) =
          friScheduleFold (μ := μ) p.toFriScheduleParams i pub)
    (hNotConst : ∀ i : Fin p.k,
      ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k,
            ((p.m_seq i -
                (p.m_seq i - (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i + 1 : ℕ) : ℕ) :
              ENNReal) /
              (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k,
            ENNReal.ofReal ((proximitySlackSeqRSFold (μ := μ) p d0) i) := by
  classical
  have hDimLe : ∀ i : Fin p.k, (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i ≤ p.m_seq i := by
    intro i
    simp [rsDimSeqFold]
  have hDimPos : ∀ i : Fin p.k, 0 < (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i := by
    intro i
    have hmpos : 0 < p.m_seq i :=
      FRIDimensionSchedule.pos_of_lt (h := p.hSched) (i := (i : ℕ)) (hi := i.is_lt)
    have hm1 : 1 ≤ p.m_seq i := Nat.succ_le_iff.mp hmpos
    have hd1 : 1 ≤ Nat.max 1 (d0 / Nat.pow 2 (i : ℕ)) := Nat.le_max_left _ _
    have hmin1 :
        1 ≤ Nat.min (Nat.max 1 (d0 / Nat.pow 2 (i : ℕ))) (p.m_seq i) := le_min hd1 hm1
    have : 0 < Nat.min (Nat.max 1 (d0 / Nat.pow 2 (i : ℕ))) (p.m_seq i) :=
      Nat.lt_of_lt_of_le Nat.zero_lt_one hmin1
    simpa [rsDimSeqFold] using this
  simpa [proximitySlackSeqRSFold] using
    (friSchedule_proximity_bound_sum_scaled_rs_tight (μ := μ) (p := p)
      (dim := rsDimSeqFold (μ := μ) p.toFriScheduleParams d0)
      (hk := hk) (pub := pub) (hDimPos := hDimPos) (hDimLe := hDimLe)
      (αs := αs) (hInj := hInj) (x := x) (hFold := hFold) (hNotConst := hNotConst))

/-! ### RS-membership phrasing (low-degree predicate)

The lemmas above take explicit witnesses `x` and equalities `hFold` asserting that
each round’s folded oracle is a Reed–Solomon codeword. The following definitions
package that as a single predicate using `inReedSolomon`, and provide a
`fri_security_complete`-style wrapper lemma that eliminates the explicit witnesses
via choice.
-/

/-- Round-level RS membership: the folded oracle is a codeword of the RS matrix. -/
def lowDegreeRSRound (p : FriScheduleParams (μ := μ)) (i : Fin p.k)
    (n : ℕ) (αs : Fin (p.m_seq i) → ℚ) (pub : Fin (p.m_seq 0) → ℚ) : Prop :=
  inReedSolomon
    (reedSolomonMatrix (α := ℚ) (m := p.m_seq i) (n := n) αs)
    (friScheduleFold (μ := μ) p i pub)

/-- Schedule-level RS membership: each round’s folded oracle is an RS codeword with
per-round dimension `dim i` and evaluation points `αs i`. -/
def lowDegreeRS (p : FriScheduleParams (μ := μ)) (dim : Fin p.k → ℕ)
    (αs : ∀ i : Fin p.k, Fin (p.m_seq i) → ℚ) (pub : Fin (p.m_seq 0) → ℚ) : Prop :=
  ∀ i : Fin p.k, lowDegreeRSRound (μ := μ) (p := p) i (dim i) (αs i) pub

/-- "Complete" RS-based proximity bound phrased using RS membership.

This matches the intended `fri_security_complete` shape: under explicit proximity
parameters and RS-membership hypotheses for each folded round-oracle, acceptance
probability is bounded by the RS-derived per-round soundness bounds plus the
`q/η/s` proximity slack.
-/
theorem fri_security_complete_rs_fold (p : FriProximityParams (μ := μ))
    (d0 : ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (αs : ∀ i : Fin p.k, Fin (p.m_seq i) → ℚ)
    (hInj : ∀ i : Fin p.k, Function.Injective (αs i))
    (hRS :
      lowDegreeRS (μ := μ) (p := p.toFriScheduleParams)
        (dim := rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) αs pub)
    (hNotConst : ∀ i : Fin p.k,
      ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k,
            ((p.m_seq i -
                (p.m_seq i - (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i + 1 : ℕ) : ℕ) :
              ENNReal) /
              (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k,
            ENNReal.ofReal ((proximitySlackSeqRSFold (μ := μ) p d0) i) := by
  classical
  -- choose explicit witnesses `x i` for each round’s RS membership
  let x : ∀ i : Fin p.k, Fin ((rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) → ℚ :=
    fun i =>
      Classical.choose (hRS i)
  have hFold :
      ∀ i : Fin p.k,
        Matrix.mulVec
            (reedSolomonMatrix (α := ℚ) (m := p.m_seq i)
              (n := (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) (αs i))
            (x i) =
          friScheduleFold (μ := μ) p.toFriScheduleParams i pub := by
    intro i
    simpa [lowDegreeRS, lowDegreeRSRound] using Classical.choose_spec (hRS i)
  exact
    friSchedule_proximity_bound_sum_scaled_rs_tight_fold (μ := μ) (p := p) (d0 := d0)
      (hk := hk) (pub := pub) (αs := αs) (hInj := hInj) (x := x)
      (hFold := hFold) (hNotConst := hNotConst)

lemma friSchedule_proximity_bound_sum_scaled_rs_constDim (p : FriProximityParams (μ := μ))
    (d : ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (fun i => Nat.min d (p.m_seq i)) i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (fun i => Nat.min d (p.m_seq i)) i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (fun i => Nat.min d (p.m_seq i)) i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
              ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k,
                ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (fun i => Nat.min d (p.m_seq i)) i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

lemma friSchedule_proximity_bound_sum_scaled_rs_baseDim (p : FriProximityParams (μ := μ))
    (d : ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqConst (μ := μ) p.toFriScheduleParams d) i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqConst (μ := μ) p.toFriScheduleParams d) i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqConst (μ := μ) p.toFriScheduleParams d) i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
              ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k,
                ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqConst (μ := μ) p.toFriScheduleParams d) i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

lemma friSchedule_proximity_bound_sum_scaled_rs_fold (p : FriProximityParams (μ := μ))
    (d0 : ℕ) (hk : 0 < p.k) (pub : Fin (p.m_seq 0) → ℚ)
    (hNotConst : ∀ i, ¬ isConst (friScheduleFold (μ := μ) p.toFriScheduleParams i pub)) :
    μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
      ≤ ∑ i : Fin p.k, ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        + ∑ i : Fin p.k, ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) := by
  classical
  have hBase :
      μ (friScheduleAccept (μ := μ) (p.toFriScheduleParams) pub)
        ≤ ∑ i : Fin p.k,
            ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal) :=
    friSchedule_soundness_bound_sum (μ := μ) (p := p.toFriScheduleParams)
      (hk := hk) (pub := pub) (hNotConst := hNotConst)
  have hSlack_nonneg :
      0 ≤ ∑ i : Fin p.k,
          ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) := by
    have hEach :
        ∀ i : Fin p.k,
          0 ≤ ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) := by
      intro i; exact bot_le
    exact Finset.sum_nonneg (fun i _ => hEach i)
  have hAdd :
      ∑ i : Fin p.k,
          ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
        ≤
          ∑ i : Fin p.k,
              ((p.m_seq i - 1 : ℕ) : ENNReal) / (p.m_seq i : ENNReal)
            + ∑ i : Fin p.k,
                ENNReal.ofReal (proximitySlackSeqRS (μ := μ) p (rsDimSeqFold (μ := μ) p.toFriScheduleParams d0) i) :=
    le_add_of_nonneg_right hSlack_nonneg
  exact le_trans hBase hAdd

end Example
end FRI
end Spec
end ZK
end Crypto
end HeytingLean
